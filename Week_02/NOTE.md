hashmap底层是什么实现的数组么？
hashmap和hashtable map怎么设置为不同步的？是说在hashtable中方法上都有sychronozed么？
hashtable的同步就是指他的方法都有sychronized的限定，线程安全和StringBuffer一样
而hashmap和StringBuilder一样去除了这种限定，让其更受欢迎

hash表是啥？hash冲突，hash一致，hashcode？

hash表又叫散列表，把离散的数存储在有序的数组中，存储的位置是用要存的数 模以 数组长度，如果存储的是字符串，进行hashcode计算为一个hash值去模数组长度，如果模后的值一致就是说发生了hash冲突，hash冲突的解决方法，再次hash，链表法，地址重定向。hashmap和redis中用的就是链表法，调用equals比较地址值看是否是同一对象，是就不存储，不是就在该位置上搭建一个链表，存储hash冲突的值。
equals和hashcode的区别
hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。
      那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面
比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。
hash值怎么生成？
用内存地址值进行hash计算，得到hashcode。
 那么hashCode()既然效率这么高为什么还要equal()呢？
hashcode的算法可能在数组长度范围内重复，所以还需要进行equals比较。
    
public int hashCode()：hashCode是Obeject中的方法。默认情况下，Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。 
那为什么重写hashcode，jvm中地址上只能存一个对象啊？所以说他的这个说法不对！hashcode是根据内存地址值，进行hash计算后得到的一个在数组上的索引。
那再次hash又是什么？第一次都hashcode一样，一次不还一样么？

还有hash一致又是什么，没有在整个hashmap存储中体现啊？在解决分布式Cache中提出的。最终一致性，最终都在2^32次这个环上。
https://www.cnblogs.com/study-everyday/p/8629100.html
key值为图片名称，value为该图片所在文件服务器的路径。
使用Hash的方式 ，每一张图片在进行分库的时候都可以定位到特定的服务器
hash(图片名称) % N 


因为图片的名称是不重复的，所以，当我们对同一个图片名称做相同的哈希计算时，得出的结果应该是不变的，如果我们有4台服务器，使用哈希后的结果对4求余，那么余数一定是0、1、2或3，没错，正好与我们之前的服务器编号相同。

HASH算法进行缓存时，会出现一些缺陷。主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据。造成了缓存的雪崩（在某一个时间段，缓存集中过期失效）

一致性哈希的基本概念

问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。
问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？
解决这些问题，一致性哈希算法诞生了。
一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模


圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1。
假设我们有4台缓存服务器，服务器A、服务器B、服务器C，服务器D，那么，在生产环境中，这4台服务器肯定有自己的IP地址或主机名，我们使用它们各自的IP地址或主机名作为关键字进行哈希计算，使用哈希后的结果对2^32取模
hash（服务器A的IP地址） %  2^32

用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上。
四台服务器使用IP地址哈希后在环空间的位置如下：

缓存的数据怎么找的最近的服务器的？用如下算法定位数据访问到相应服务器：  将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！
例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：

根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。

一致性Hash算法的容错性和可扩展性
Node C不幸宕机

可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器。

Hash环的数据倾斜问题

一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题

如果想要均衡的将缓存分布到2台服务器上，最好能让这2台服务器尽量多的、均匀的出现在hash环上，但是，真实的服务器资源只有2台，我们怎样凭空的让它们多起来呢，没错，就是凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有的物理节点通过虚拟的方法复制出来。
这些由实际节点虚拟复制而来的节点被称为"虚拟节点"，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。
例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：

在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。

缓存雪崩，缓存穿透，缓存击穿
https://baijiahao.baidu.com/s?id=1619572269435584821&wfr=spider&for=pc
缓存雪崩：是指在某一个时间段，缓存集中过期失效
缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用

HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。

TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。

hash一致性和hash槽的区别
它并不是闭合的，key的定位规则是根据CRC-16(key)%16384的值来判断属于哪个槽区，从而判断该key属于哪个节点，而一致性哈希是根据hash(key)的值来顺时针找第一个hash(ip)的节点，从而确定key存储在哪个节点。
redis集群三种模式，我才用的是cluster无主从模式
https://www.cnblogs.com/51life/p/10233340.html


