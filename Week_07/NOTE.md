分布式中常用，比特币，MR中也在用



1-8各自为营
经过一系列操作后，形成3个集合
使用并查集可以很方便的把12568，34，7形成集合

主要功能：
找老大
合并集合：很方便的把12568，34合并成一个集合
查询两个数是否在同一个集合：查询5，3是否在一个集合中


并查集实现的数据思想：
1.小弟->老大（大boss的老板就是自己）
2.帮派识别
3.两种优化方式：
优化合并小集合指向大的集合
路径压缩：一次次的向上找老大太慢，直接记录自己的最终boss

并查集实现：

一般用数组实现

初始化：数组的值指向自己的下标，自己的老大是自己（各自为营）
findRoot找到老大（向上循环的找最终boss，找到最终boss后，把所有的小弟都指向最终boss）判断一个元素属于哪个集合，当前元素不断的往root上找，一直找到roots[a]==a的时候就说明找到了他的老大
connected判断pq是否在一个集合中
pq合并到一个集合中（找到最终boss，当前的老大指向另外一个老大）

通过合并并查集的操作后形成这样的结果




并查集的两种优化
1.深度低的子集合并到深度高的子集中。会生成一个总体rank较低的子集

合并集合，1指向3或者3指向1。那种好？
组成链，不如组成树（链表：查2的老大，向上走2个节点。树，查2的boss向上走1次，递归的走一次就行。）

目标：合并时降低深度，尽可能少的执行递归找到boss

并查集中我们把深度称为rank（约定俗成，在这不称作deep）







当两个集合深度一样的时候，y指向x，x的深度加1。


缺点：多创建一个rank，浪费空间

2.路径压缩（指向最终boss）

find找到root，之后给每个节点赋值最终boss--root

 
